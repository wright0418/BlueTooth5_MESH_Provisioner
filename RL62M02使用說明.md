# RL62M02套件使用說明

## 簡介

RL62M02是一個用於控制和配置RL Mesh設備的Python套件。該套件提供了與RL Mesh設備通訊的功能，包括設備掃描、配置、控制等操作。透過這個套件，使用者可以輕鬆地管理多種RL Mesh設備，如RGB LED燈、智能插座、空氣盒子和電錶等。

## 套件結構

RL62M02套件包含以下主要組件：

- **SerialAT**: 負責與設備進行串口通訊，處理AT指令的發送和接收
- **Provisioner**: 負責RL Mesh設備的配置和管理，包括設備掃描、綁定等操作
- **ModbusRTU**: 負責處理Modbus RTU協議，用於與支援Modbus的設備通訊
- **RLMeshDeviceController**: 提供設備控制功能，用於控制多種RL Mesh設備
- **MeshDeviceManager**: 整合設備資訊管理、操作等功能的統一介面
- **rl62m02/device_manager.py**: 套件內建的 MeshDeviceManager 類，提供設備資料管理、存取、控制等統一介面


## 安裝方式

您可以通過以下方式安裝RL62M02套件：

```bash
# 直接從目錄安裝
cd rl62m02
pip install -e .

# 或者，如果已經打包
pip install rl62m02-0.1.0.tar.gz
```

## 使用流程

使用RL62M02套件的基本流程如下：

1. 初始化通訊和配置
2. 掃描設備
3. 配置和綁定設備
4. 控制設備功能

下面將詳細說明每一步的操作。

### 1. 初始化通訊和配置

首先，您需要初始化SerialAT和Provisioner物件，建立與設備的通訊：

```python
from rl62m02 import create_provisioner

# 快速初始化（一行代碼創建所需的所有物件）
serial_at, provisioner, device_manager = create_provisioner("COM3", 115200)

# 檢查設備版本
version = provisioner.get_version()
print(f"設備版本: {version}")
```

### 2. 掃描設備

初始化完成後，您可以掃描周圍的RL Mesh設備：

```python
# 使用便捷函數掃描設備
from rl62m02 import scan_devices

devices = scan_devices(provisioner, scan_time=5.0)
print(f"發現 {len(devices)} 個設備:")
for i, device in enumerate(devices):
    print(f"{i+1}. UUID: {device['uuid']}, MAC地址: {device['mac address']}")

# 或者直接使用Provisioner類的方法
# devices = provisioner.scan_nodes(scan_time=5.0)
```

### 3. 配置和綁定設備

找到設備後，您可以配置並綁定它們：

```python
# 使用便捷函數配置設備
from rl62m02 import provision_device

# 假設我們要配置第一個掃描到的設備
if devices:
    result = provision_device(
        provisioner, 
        devices[0]['uuid']
    )
    
    if result.get('result') == 'success':
        print(f"設備配置成功，Unicast地址: {result.get('unicast_addr')}")
    else:
        print(f"設備配置失敗: {result}")

# 或者使用Provisioner的方法手動配置
# result = provisioner.auto_provision_node(devices[0]['uuid'])
```

### 4. 控制設備功能

設備配置成功後，您可以使用RLMeshDeviceController來控制不同類型的設備：

```python
from rl62m02.controllers.mesh_controller import RLMeshDeviceController

# 初始化控制器
device_controller = RLMeshDeviceController(provisioner)

# 註冊設備（使用從配置過程中獲得的unicast地址）
unicast_addr = result.get('unicast_addr')  # 例如: "0x0100"
device_controller.register_device(unicast_addr, "RGB_LED", "客廳燈")

# 控制RGB LED燈（調整亮度和顏色）
# 參數: cold, warm, red, green, blue（所有值範圍0-255）
device_controller.control_rgb_led(unicast_addr, 0, 255, 0, 0, 0)  # 設為紅色
```

## 支援的設備類型及控制方法

### RGB LED燈

```python
# 控制RGB LED燈
# 參數: cold(冷光), warm(暖光), red(紅), green(綠), blue(藍)
device_controller.control_rgb_led(unicast_addr, 0, 0, 255, 0, 0)  # 紅色
device_controller.control_rgb_led(unicast_addr, 0, 0, 0, 255, 0)  # 綠色
device_controller.control_rgb_led(unicast_addr, 0, 0, 0, 0, 255)  # 藍色
device_controller.control_rgb_led(unicast_addr, 255, 255, 0, 0, 0)  # 白色
```

### 智能插座

```python
# 控制智能插座
# 註冊插座設備
device_controller.register_device(unicast_addr, "PLUG", "客廳插座")

# 控制開關（參數: True開/False關）
device_controller.control_plug(unicast_addr, True)  # 開啟插座
device_controller.control_plug(unicast_addr, False)  # 關閉插座
```

### 空氣盒子

```python
# 控制空氣盒子
# 註冊空氣盒子設備
device_controller.register_device(unicast_addr, "AIR_BOX", "客廳空氣盒子")

# 讀取環境數據（參數: 從站地址，通常為1）
env_data = device_controller.read_air_box_data(unicast_addr, 1)
print(f"溫度: {env_data['temperature']}°C")
print(f"濕度: {env_data['humidity']}%")
print(f"PM2.5: {env_data['pm25']}μg/m³")
print(f"CO2: {env_data['co2']}ppm")
```

### 電錶

```python
# 控制電錶
# 註冊電錶設備
device_controller.register_device(unicast_addr, "POWER_METER", "配電箱電錶")

# 讀取電力數據（參數: 從站地址，通常為1）
power_data = device_controller.read_power_meter_data(unicast_addr, 1)
print(f"電壓: {power_data['voltage']}V")
print(f"電流: {power_data['current']}A")
print(f"功率: {power_data['power']}W")
```

### Smart-Box設備（通用Modbus功能）

```python
# 控制Smart-Box設備（通用功能）
# 註冊Smart-Box設備
device_controller.register_device(unicast_addr, "SMART_BOX", "通用控制器")

# 讀取保持寄存器
# 參數: 從站地址, 功能碼, 起始地址, 數量
result = device_controller.read_smart_box_rtu(
    unicast_addr, 1, device_controller.modbus.READ_HOLDING_REGISTERS, 0, 10
)

# 寫入單個寄存器
# 參數: 從站地址, 寄存器地址, 寄存器值
result = device_controller.write_smart_box_register(
    unicast_addr, 1, 0, 100
)

# 寫入多個寄存器
# 參數: 從站地址, 起始地址, 寄存器值列表
result = device_controller.write_smart_box_registers(
    unicast_addr, 1, 0, [100, 200, 300]
)

# 寫入單個線圈
# 參數: 從站地址, 線圈地址, 線圈值
result = device_controller.write_smart_box_coil(
    unicast_addr, 1, 0, True
)
```

## 完整範例：掃描、配置和控制設備

以下是一個完整的範例，展示如何掃描、配置和控制RL Mesh設備：

```python
from rl62m02 import create_provisioner, scan_devices, provision_device
from rl62m02.controllers.mesh_controller import RLMeshDeviceController
import time

def main():
    # 1. 初始化通訊和配置
    print("初始化設備...")
    serial_at, provisioner, device_manager = create_provisioner("COM3", 115200)
    
    # 2. 掃描設備
    print("掃描設備中...")
    devices = scan_devices(provisioner, scan_time=5.0)
    print(f"發現 {len(devices)} 個設備:")
    for i, device in enumerate(devices):
        print(f"{i+1}. UUID: {device['uuid']}, MAC地址: {device['mac address']}")
    
    if not devices:
        print("未找到設備，請確認設備已開啟並在範圍內")
        return
    
    # 3. 選擇並配置設備
    target_device = devices[0]  # 選擇第一個設備
    print(f"開始配置設備 {target_device['uuid']}...")
    
    result = provision_device(
        provisioner, 
        target_device['uuid']
    )
    
    if result.get('result') != 'success':
        print(f"設備配置失敗: {result}")
        return
        
    unicast_addr = result.get('unicast_addr')
    print(f"設備配置成功，Unicast地址: {unicast_addr}")
    
    # 4. 控制設備
    print("初始化設備控制器...")
    device_controller = RLMeshDeviceController(provisioner)
    device_controller.register_device(unicast_addr, "RGB_LED", "測試燈")
    
    print("開始控制設備...")
    
    # 設置為紅色
    print("設置為紅色...")
    device_controller.control_rgb_led(unicast_addr, 0, 0, 255, 0, 0)
    time.sleep(2)
    
    # 設置為綠色
    print("設置為綠色...")
    device_controller.control_rgb_led(unicast_addr, 0, 0, 0, 255, 0)
    time.sleep(2)
    
    # 設置為藍色
    print("設置為藍色...")
    device_controller.control_rgb_led(unicast_addr, 0, 0, 0, 0, 255)
    time.sleep(2)
    
    # 設置為白色
    print("設置為白色...")
    device_controller.control_rgb_led(unicast_addr, 255, 255, 0, 0, 0)
    
    print("設備控制演示完成")

if __name__ == "__main__":
    main()
```

## 注意事項

1. **設備通訊順序**：必須先初始化通訊，然後掃描設備，再進行配置和控制。

2. **設備類型匹配**：控制設備時請確保註冊的設備類型與實際設備類型匹配。

3. **超時處理**：網絡通訊可能會有延遲，如果控制指令沒有立即得到響應，可能需要增加超時時間或重試機制。

4. **錯誤處理**：在實際應用中，應該加入更多錯誤處理機制，確保程式的穩定性。

5. **設備存儲**：配置完成後，設備信息會保存在`mesh_devices.json`文件中，下次可以直接使用。

## 進階功能

### 1. 設備管理器

使用`DeviceManager`類可以持久化管理設備信息：

```python
if device_manager:
    # 查詢所有已配置的設備
    devices = device_manager.get_all_devices()
    print("已配置的設備:")
    for uuid, device in devices.items():
        print(f"UUID: {uuid}, 名稱: {device['name']}, 地址: {device['unicast_addr']}")
    
    # 根據UUID查詢設備
    device = device_manager.get_device_by_uuid("設備UUID")
    if device:
        print(f"找到設備: {device['name']}")
    
    # 根據名稱查詢設備
    device = device_manager.get_device_by_name("設備名稱")
    if device:
        print(f"找到設備: {device['unicast_addr']}")
```

#### 1.1 內建 MeshDeviceManager

rl62m02 套件內建的 MeshDeviceManager 類提供設備資料管理、存取、控制等統一介面：

```python
from rl62m02 import create_provisioner
from rl62m02.controllers.mesh_controller import RLMeshDeviceController
from rl62m02.device_manager import MeshDeviceManager

# 初始化
serial_at, provisioner, _ = create_provisioner("COM3", 115200)
controller = RLMeshDeviceController(provisioner)
device_manager = MeshDeviceManager(provisioner, controller, "mesh_devices.json")

# 掃描設備
scan_result = device_manager.scan_devices(scan_time=5.0)
print(f"找到 {len(scan_result)} 個設備")

# 綁定設備
result = device_manager.provision_device(
    uuid="12345678abcdef",
    device_name="客廳燈",
    device_type="RGB_LED", 
    position="客廳"
)

if result["result"] == "success":
    print(f"設備綁定成功: {result['unicast_addr']}")
    
# 設定訂閱
device_manager.set_subscription("0x0100", "0xC000")

# 設定推播
device_manager.set_publication("0x0100", "0xC001")

# 控制設備
# RGB LED 控制
device_manager.control_device("0x0100", "set_rgb", red=255, green=0, blue=0)
device_manager.control_device("0x0100", "set_white", cold=255, warm=255)
device_manager.control_device("0x0100", "turn_off")

# 插座控制
device_manager.control_device("0x0101", "toggle")  # 切換開關狀態
device_manager.control_device("0x0101", "turn_on")
device_manager.control_device("0x0101", "turn_off")

# 解除綁定設備
device_manager.unbind_device("0x0100")

# 顯示所有設備
print(device_manager.display_devices())
```

#### 1.2 獨立 MeshDeviceManager

根目錄下的 mesh_device_manager.py 模組提供另一種 MeshDeviceManager 類實作，著重於綁定、解綁、自動重綁等進階功能：

```python
from mesh_device_manager import MeshDeviceManager

# 初始化 - 注意這與內建版本不同，這裡直接傳入串口信息
manager = MeshDeviceManager("COM3", 115200, "devices.json")

# 掃描裝置
manager.scan_devices(scan_time=5.0)

# 綁定單一裝置
result = manager.provision_device(
    uuid="12345678abcdef", 
    device_name="客廳燈",
    subscribe_uid="0xC000",  # 非必要，訂閱地址
    publish_uid="0xC000"     # 非必要，推播地址
)

# 互動式掃描與綁定 (將顯示掃描到的設備並引導用戶選擇)
manager.scan_and_bind(scan_time=5.0)

# 解除所有裝置的綁定
result = manager.unprovision_all_devices()

# 從JSON檔案自動綁定裝置
result = manager.auto_provision_from_json(input_format="standard")
# 或者從Node-RED格式檔案綁定
result = manager.auto_provision_from_json(input_format="nodered", input_file="nodered_devices.json")

# 重置並綁定特定裝置
result = manager.reset_and_bind(
    uuid="12345678abcdef", 
    device_name="客廳燈",
    subscribe_uid="0xC000", 
    publish_uid="0xC000"
)
```

### 2. 觀察模式

使用`observe`方法可以持續監聽設備發送的消息：

```python
# 進入觀察模式（按Ctrl+C退出）
try:
    print("進入觀察模式，監聽設備消息...")
    provisioner.observe()
except KeyboardInterrupt:
    print("退出觀察模式")
```

### 3. 進階控制選項

設備控制可以使用更多選項：

```python
# 發送自定義數據到設備
data = "870100050102030405"  # 自定義命令
resp = provisioner.send_datatrans(unicast_addr, data)

# 接收設備發送的數據
resp = provisioner.get_datatrans(unicast_addr, 10)  # 10 為讀取的數據長度

# 處理Provisioner增強功能
# 獲取當前已綁定設備列表
node_list = provisioner.get_node_list()
print(f"已綁定設備列表: {node_list}")

# 為設備設定AppKey綁定
provisioner.set_appkey(unicast_addr, app_key_index=0, net_key_index=0)

# 解除節點綁定
provisioner.node_reset(unicast_addr)

# 將設備訂閱到群組，可指定特定的元素索引和模型ID
provisioner.subscribe_group(unicast_addr, group_addr="0xC000", element_index=0, model_id="0x4005D")

# 設定設備推播到目標，可指定特定的元素索引、模型ID和AppKey索引
provisioner.publish_to_target(unicast_addr, publish_addr="0xC001", element_index=0, model_id="0x4005D", app_key_idx=0)

# 設定設備名稱
provisioner.set_name("RL62M02_Device")

# 重啟設備
provisioner.reboot()

# 查詢設備角色
role = provisioner.get_role()
print(f"設備角色: {role}")
```

## 故障排除

1. **無法掃描到設備**
   - 確保設備已開啟電源並在藍牙範圍內
   - 檢查COM端口配置是否正確
   - 檢查藍牙適配器是否正常工作

2. **配置失敗**
   - 確保設備未被其他provisioner配置
   - 檢查錯誤消息確定具體問題
   - 嘗試重啟設備並重新掃描

3. **控制指令無響應**
   - 確認unicast地址是否正確
   - 檢查設備是否被正確配置
   - 檢查設備類型是否設定正確

## 結論

RL62M02套件提供了強大而靈活的功能，可以輕鬆地配置和控制各種RL Mesh設備。通過遵循上述使用流程和範例，初學者可以快速上手這個套件，開始開發自己的RL Mesh應用。